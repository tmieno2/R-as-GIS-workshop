---
title: "R as GIS: Vector Data Basics with the sf package"
format: 
  revealjs: 
    theme: [default, custom.scss]
    fontsize: 1em
    callout-icon: false
    scrollable: true
    echo: true
webr:
  packages: ['ggplot2', 'dplyr', 'sf', 'data.table'] # Install R packages on document open
# autoload-packages: false       # Disable automatic loading of packages
# show-startup-message: false    # Disable displaying status of webR initialization
  cell-options:
    editor-font-scale: 0.7
filters:
- webr
---


## Before you start

### Learning objectives

The objectives of this chapter is to learn how to use R as GIS, specifically how to handle vector spatial data.

### Table of contents

1. [Understanding the data structure of `sf`](@sec-data-structure)
2. [Create sf objects yourself](#create-sf)
3. [Different Types of Simple Feature Geometry (`sfg`)](#dif-sfg)
4. [Constructing `sfc` and `sf` from `sfg`](#const)
5. [Importing and exporting spatial datasets](#input-output)
6. [Projection](#proj)
7. [Quick and Interactive View of an `sf` Object](#view)
8. [Conversion to and from `sp` objects](#sf-to-sp)
9. [Non-spatial Transformation of `sf`](#non-trans)
10. [Non-interactive geometrical operations](#non-int-geo)

```{webr-r}
#| context: setup
nc <-
  st_read(system.file("shape/nc.shp", package = "sf")) %>%
  dplyr::select(AREA, NAME, FIPS)
```

##  Prerequisites and Preparation

::: {.callout-tip title="Prerequisites"}
+ What Geographic Coordinate System (GCS), Coordinate Reference System (CRS), and projection are ([this](https://annakrystalli.me/intro-r-gis/gis.html) is a good resource)

+ Distinctions between vector and raster data ([this](https://gis.stackexchange.com/questions/57142/what-is-the-difference-between-vector-and-raster-data-models) is a simple summary of the difference)
:::


::: {.callout-tip title="Preparation"}
+ Set the working directory to a directory

+ Create the "Data" folder under the directory you have set as the working directory 

+ Go [here](https://www.dropbox.com/sh/iih8icftc4xa7nm/AABfQj82A-i8GWaHgHngLMQAa?dl=0), download all the files, and then save them in the "Data" folder you created in the step above
:::

## Introduction

+ The `sf` package provides a simply way of storing geographic information and the attributes of the geographic units in a single dataset called simple feature (`sf`).

+ The `sf` package allows you to do almost all the spatial operations you would need for your research
  * Projection
  * Read/write to spatial datasets in various formats (including shape files)
  * Non-interactive geometrical operations
    - create buffers
    - calculate area 
    - calculate distance 
  * Interactive geometrical operations
    - spatially subset datasets
    - extracting values from the intersecting spatial objects

## Preparation 

Read the North Carolina county boundary data: 

```{webr-r}
nc <-
  st_read(system.file("shape/nc.shp", package = "sf")) %>%
  dplyr::select(AREA, NAME, FIPS)
```

Check the class:

```{webr-r}
class(nc)
```

## Data structure of `sf` {#sec-data-structure}

:::: {.columns}
::: {.column width="50%"}
```{webr-r}
nc  
```
:::
::: {.column width="50%"}
+ The first line tells you this is an simple feature (`sf`) object with 100 features and 3 attributes (fields)

+ So, an `sf` object looks just like a `data.frame` where rows representing observation units, columns representing attributes, except for a special column named `geometry` 

+ The `geometry` column stores the geographic information of the observation units (here, county)


:::{.callout-note title="Example"}
Ashe County (1st row) has area of 0.114, FIPS code of 37009, and so on. And the entry in geometry column at the first row represents the geographic information of Ashe County.
:::

:::
::::

## The `geometry` column 

:::: {.columns}
::: {.column width="50%"}
```{webr-r}
dplyr::select(nc, geometry)
```
:::
::: {.column width="50%"}
+ An entry of the `geometry` columns is an simple feature geometry (`sfg`).

+ In general, `sfg` represents the geographic information of a single geometric feature (here, county).

+ There are different types of `sfg`s (POINT, LINESTRING, POLYGON, MULTIPOLYGON, etc)

+ In this example, all the `sfg`s are of type `MULTIPOLYGON`

+ A collection of multiple `sfg`s as a column is called simple feature geometry column (`sfc`), which can make a `geometry` column in an `sf` object

:::
::::

## Simple Feature Geometry (`sfg`) 

:::: {.columns}
::: {.column width="60%"}
Let's see what an `sfg` is made of.

```{webr-r}
st_geometry(nc[1, ])[[1]][[1]][[1]] %>% head(10)
```

:::

::: {.column width="40%"}
<br>

+ Each row represents a point 
	* 1st column: longitude
	* 2nd column: latitude

+ Points are stored in a matrix format

+ Connecting all the points forms a polygon
:::
::::

## Different Types of Simple Feature Geometry (`sfg`) 

Some of the moist common types of spatial objects represented by `sfg` are the following:

+ `POINT`: area-less feature that represents a point (e.g., well, city, farmland) 

+ `LINESTRING`: (e.g., a tributary of a river) 

+ `MULTILINESTRING`: (e.g., river with more than one tributary) 

+ `POLYGON`: geometry with a positive area (e.g., county, state, country)

+ `MULTIPOLYGON`: collection of polygons to represent a single object (e.g., countries with islands: U.S., Japan, etc)

## Simple Feature Geometry (`sfg`) 

::: {.panel-tabset}
### `POINT`

`POINT` is the simplest geometry type and is represented by a vector of two numeric values. An example below shows how a `POINT` feature can be made from scratch:

```{webr-r}
#--- create a POINT ---#
a_point <- st_point(c(2,1))
```

The `st_point()` function creates a `POINT` object when supplied with a vector of two numeric values. If you check the class of the newly created object,

<br>

```{webr-r}
#--- check the class of the object ---#
class(a_point)
```

you can see that it's indeed a `POINT` object. But, it's also an `sfg` object. So, `a_point` is an `sfg` object of type `POINT`. 

### `LINESTRING`

A `LINESTRING` object is represented by a sequence of points in a matrix:  

```{webr-r}
#--- collection of points in a matrix form ---#
(
s1 <- rbind(c(2,3),c(3,4),c(3,5),c(1,5))
)
```

You can turn the matrix into a LINESTRING using `sf::st_linestring()`:

```{webr-r}
#--- create a "LINESTRING" ---#
a_linestring <- sf::st_linestring(s1)

#--- check the class ---#
class(a_linestring)
```

Let's plot it.

```{webr-r}
plot(a_linestring)
```

As you can see, each pair of consecutive points in the matrix are connected by a straight line to form a line. 

### `POLYGON`


+ Just like the `LINESTRING` object we created earlier, a `POLYGON` is represented by a collection of points. 
+ However, the first and last points in the matrix have to be the same to form a polygon 

```{webr-r}
(p1 <- rbind(c(0,0), c(3,0), c(3,2), c(2,5), c(1,3), c(0,0)))
```

You can turn the matrix into a POLYGON using `st_polygon()`, which takes a matrix in a `list()` :

```{webr-r}
a_polygon <- st_polygon(list(p1))

class(a_polygon)
```

Let's plot it.
```{webr-r}
plot(a_polygon, col = "red")
```

###  `POLYGON` with holes

+ A `POLYGON` can have holes in it.

+ The first matrix of a list becomes the exterior ring, and all the subsequent matrices will be holes within the exterior ring.  

```{webr-r}
#--- a hole within p1 ---#
p2 <- rbind(c(1,1), c(1,2), c(2,2), c(1,1))

#--- create a polygon with hole ---#
a_plygon_with_a_hole <- st_polygon(list(p1,p2))
```

Let's plot it.

```{webr-r}
#--- see what it looks like ---#
plot(a_plygon_with_a_hole, col = "red")
```

### `MULTIPOLYGON`

To create a `MULTIPOLYGON` object you create a list of lists of matrices, with each inner list representing a polygon.  

```{webr-r}
#--- create a matrix for another polygon ---#
p3 <- rbind(c(4,0), c(5,0), c(5,3), c(4,2), c(4,0)) 
```

You supply a list of lists of matrices to the `st_multipolygon()` function to make a `MULTIPOLYGON` object.

```{webr-r}
a_multipolygon <- 
  st_multipolygon(
    list(
      list(p1,p2), # the polygon with a hole
      list(p3) # the new polygon created above
    )
  )
```

Each of `list(p1,p2)` and `list(p3)` represents a polygon.

```{webr-r}
plot(a_multipolygon, col = "red")
```

:::

## Exercises

::: {.panel-tabset}

###  Create a `POINT`

```{webr-r}

```

###  Create a `LINESTRING`

```{webr-r}

```

###  Create a `POLYGON` 

```{webr-r}
 
```

:::


## Constructing `sfc` from `sfg`

`sfg` is an object class that represents a single spatial object.

. . .

We can combine multiple `sfg`s as a list to create a simple feature geometry list-column (`sfc`).

. . .

To make a simple feature geometry list-column (`sfc`), you can simply supply a list of `sfg` to the `st_sfc()` function as follows:

```{webr-r}
#--- create an sfc ---#
sfc_ex <- sf::st_sfc(
  list(
    a_point,
    a_linestring,
    a_polygon,
    a_multipolygon
  )
)
```

. . . 

Check its class:

```{webr-r}
class(sfc_ex)
```

## Constructing an `sf` using an `sfc`

To create an `sf` object, you first add an `sfc` as a column to a `data.frame`.

```{webr-r}
#--- create a data.frame ---#
df_ex <- data.frame(
  name = c('A', 'B', 'C', 'D')
)

#--- add the sfc as a column ---#
df_ex$geometry <- sfc_ex 
```

. . .

At this point, it is not yet recognized as an `sf` by R yet.

```{webr-r}
class(df_ex)
```

. . .

You can register it as an `sf` object using `st_as_sf()`.

```{webr-r}
#--- let R recognize the data frame as sf ---#
sf_ex <- st_as_sf(df_ex)

#--- see what it looks like ---#
sf_ex
```

. . .

As you can see `sf_ex` is now recognized also as an `sf` object.

```{webr-r}
#--- check the class ---#
class(sf_ex)
```

## Exercises 2

::: {.panel-tabset}

### Exercises 2.1

Create an `sfc` using the `POINT` and `POLYGON` you made earlier.

```{webr-r}
a_point 

a_polygon
```

### Exercises 2.2

Create an `sf` object using the `sfc` object you created in the previous exercise, where the additional variable in the `sf` object is `id` with the `POINT` and `POLYGON` assigned `id = 1` and `id = 2`, respectively. 

```{webr-r}

```

:::

## Reading and writing vector data

::: {.panel-tabset}

### Basics

+ The vast majority of people still use ArcGIS software to handle spatial data, which has its own system of storing spatial data called [shapefile]{style="color:red"} system. 

+ shapefile is a collection of files including 
	* `.shp`: stores geometry information (like `sfg`) 
	* `.prj`: projection information 

```{r  echo = F, out.width = "70%", eval = F}
knitr::include_graphics(here::here("Lectures/assets/shpfiles.png"))
```

+ Chances are that your collaborators use shapefiles.

+ There are many GIS data online that are available only as shapefiles.

+ So, it is important to learn how to read and write shapefiles 

### Importing a shapefile

You can use `sf::st_read()` to read a shapefile. It reads in a shapefile and then turn the data into an sf object. 

#### Syntax

```{r}
#| eval: false
st_read(file_path)
```

+ `file_path`: the path to the shapefile.

<br>


#### Example

```{r}
#| eval: false
nc_imported <- st_read("Data/nc_practice.shp") 
```

Here, it is reading a file named `nc_practice.shp` (along with other related files) is read from the `Data` folder.

<br>

:::{.callout-note title="Try yourself"}
+ download **nc_practice.shp** and other supporting files to where you would like on your computer
+ find and copy the path to the file
+ import the data using `sf::st_read()`
:::

### Exporting to a shapefile

You can use the `sf::st_write()` function to write an `sf` object to shape files. 

#### Syntax

```{r write_nc}
#| eval: false
st_write(sf object, file path, append = FALSE)
```

+ Use `driver = "ESRI Shapefile"`: to write the `sf` as shape files
+ `append = FALSE` forces writing the data when the shape files with the same name already exists 

<br>

#### Example

```{r write_nc_error}
#| eval: false
st_write(nc_imported, "Data/nc_exported.shp")
```

This code will export an `sf` object called `nc_imported` as `nc_exported.shp` (along with other supporting files) in the "Data" folder relative to the working directory. 

<br>

:::{.callout-note title="Try yourself"}
+ export the sf object you read earlier using `sf::st_write()` using whatever name you like
:::


### Alternative formats

+ If your collaborator is using ArcGIS and demanding that he/she needs a shapefile for his/her work, sure you can write to a shapefile. 

+ But, there is really no need to work with the shapefile system. It is a myth that spatial datasets have to be stored as shapefile.

+ Basically, we are using the file system just because ArcGIS is the pioneer of GIS software and many people are still using it, but not because it is the best format available to store spatial objects.

+ Indeed, there are some limitations to shape files (see [here](https://carto.com/blog/fgdb-gpkg/))

+ But, first and foremost, it is annoying to have many files for a single spatial object 

### Geopackage

One of the alternative data formats that is considered superior to the shapefile system is [GeoPackage](https://www.geopackage.org/), which overcomes various limitations associated with shapefile. 

+ Unlike the shapefile system, it produces only a single file with .gpkg extension.

+ GeoPackage files can also be read into ArcGIS. 

<br>

#### Write

To write an `sf` object to a geopackage file, you simply give the file path to the `dsn` option (note that you do not use the `layer` option unlike the shape files case).

```{r gpkg}
#| eval: false

#--- write as a gpkg file ---#
st_write(nc_imported, dsn = "Data/nc_exported.gpkg")
```

<br>

#### Read

You can use the `sf::st_read()` function to read a geopacakge file like below:

```{r eval = F}
#| eval: false
nc <- st_read("Data/nc_exported.gpkg")
```

### R data set (rds) 

Or better yet, if your collaborator uses R (or if it is only you who is going to use the data), then just save an `sf` object as an rds file using `saveRDS()`, which can be of course read using `readRDS()`.

<br>

#### Save

```{r save_read_nc_as_rds, eval = F}
#--- save as an rds ---#
saveRDS(nc_imported, "Data/nc_exported.rds")
```


<br>

#### Read

```{r eval = F}
#--- read an rds ---#
nc <- readRDS("Data/nc_exported.rds")
```

<br>

:::{.callout-note title="Note"}
The use of rds files can be particularly attractive when the dataset is large because rds files are typically more memory efficient than shape files.
:::

:::


## Projection

::: {.panel-tabset}

### Motivation

You often need to reproject an `sf` using a different coordinate reference system (CRS) because you need it to have the same CRS as an `sf` object that you are interacting it with (spatial join) or mapping it with. 


### Checking the current CRS

In order to check the current CRS for an `sf` object, you can use the `sf::st_crs()` function. 

```{webr-r}
st_crs(nc)
```

<br>

+ `sf` uses the **Well Known Text** format to store the coordinate reference system (CRS), which is one of many many formats to store CRS information (See [here](https://spatialreference.org/ref/epsg/nad27/))

+ `ID["EPSG", 4267]` means that the EPSG code for this CRS is 4267
  + EPSG code is a CRS reference system developed by by European Petroleum Survey Group (EPSG) 
  + You can find the CRS-EPSG number correspondence [here](http://spatialreference.org/ref/epsg/). 

+ When you transform an `sf` using a different CRS, you can use its EPSG number if the CRS has an EPSG number
  + Potential pool of CRS is infinite. 
  + Only the commonly-used CRS have been assigned EPSG SRID. 

### Project or re-project `sf` objects

You can use `sf::st_transform()` to apply a different projection method to an `sf` object.

#### Syntax

```{r eval = F}
st_transform(sf, EPSG number or CRS in WTK)
```

<br>

#### Example

Let's transform (reproject) the data using `NAD83 / UTM zone 14N` CRS. Its EPSG number is `26914`.

```{webr-r}
nc_utm <- st_transform(nc, 26914)
```

<br>

Let's confirm the change in CRS:

```{webr-r}
st_crs(nc_utm)
```

<br>

Let's compare the geometry column before and after the transformation (projection):

```{webr-r}
dplyr::select(nc, geometry)
```

<br>

```{webr-r}
dplyr::select(nc_utm, geometry)
```

### Projection using the CRS of another `sf`  

+ You often need to change the CRS of an `sf` object when you interact (e.g., spatial subsetting, joining, etc) it with another `sf` object. 

+ In such a case, you can extract the CRS of the other `sf` object using `st_crs()` and use it for transformation.

+ So, you do not need to find the EPSG of the CRS of the `sf` object you are interacting it with.

#### Example

```{webr-r}
#--- transform ---#
nc_utm_back_to_original <-
  st_transform(
    nc_utm,
    st_crs(nc)
  )
```

Let's confirm the transformation: 

```{webr-r}
st_crs(nc_utm_back_to_original)
```

### Exercises 

#### Exercise 1

Check the CRS of `Fairway_Five`.

```{webr-r}

```

<br>

#### Exercise 2

Find the EPSG code for WGS 84, and change the CRS of `Fairway_Five` to WGS 84 using the EPSG code.

```{webr-r}

```

:::


## Quick Visualization

::: {.panel-tabset}

### Quick view using `plot()`

The easiest way to visualize an `sf` object is to use `plot()`:

```{webr-r}
plot(nc) 
```

<br>

+ `plot()` create a map for each variable where the spatial units are color-differentiated based on the values of the variable

+  We will learn how to create more elaborate maps that are of publication-quality using the `ggplot2` package later


### Interactive view using `mapView()`

Sometimes it is useful to be able to tell where certain spatial objects are and what values are associated with them on a map. 

The `mapView()` function from the `mapview` package can create an interactive map where you can point to a spatial object and the associated information is revealed on the map.


```{r eval = F}
library(mapview)

#--- generate an interactive map ---#
mapView(nc)  
```


### Interactive view using the `tmap` package

Alternatively, you could use the `tmap` package to create interactive maps. 

You can first create a static map following a syntax like this:

```{r syntax-tmap, eval = F}
#--- NOT RUN (for polygons) ---#
tm_shape(sf) +
  tm_polygons() 

#--- NOT RUN (for points) ---#
tm_shape(sf) +
  tm_symbols() 
```

Then, you can apply `tmap_leaflet()` to the static map to have an interactive view of the map.

Let's create a static map of `nc` county boundaries:

```{webr-r}
library(tmap)
tm_nc_polygons <- tm_shape(nc) + tm_polygons() 
```

Apply `tmap_leaflet()` to `tm_nc_polygons` to have this

```{webr-r}
tmap_leaflet(tm_nc_polygons)
```

:::

## Turning a data.frame of points into an `sf` 

::: {.panel-tabset}
### Motivation

+ Often times, you have a dataset with geographic coordinates as variables in a csv or other formats
 
+ It would not be recognized as a spatial dataset by R immediately when it is read into R. 

+ In this case, you need to identify which variables represent the geographic coordinates from the data set, and create an `sf` yourself. 

+ Fortunately, it is easy to do so using the `st_as_sf()` function.

### Preparation

Let's read a dataset (irrigation wells in Nebraska):

```{r data_read_as_dataframe, eval = F}
#--- read irrigation well registration data ---#
(
wells <- readRDS('./Data/well_registration.rds')  %>% 
	dplyr::select(wellid, ownerid, acres, longdd, latdd)
)
```

In this dataset, `longdd` and `latdd` represent longitude and latitude, respectively.

We also know (yes, YOU need to know the CRS of your data) that the geographic coordinates system of this data is NAD 83 (epsg=4269) for this dataset. 

```{webr-r}
download.file("https://www.dropbox.com/home/TeachingUNL/Data-Science-with-R/Chapter-8-SpatialData/blue.rds?raw=1", "data.csv")

```

:::